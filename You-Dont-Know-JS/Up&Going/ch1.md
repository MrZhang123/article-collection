根据惯例，用做常量的 JavaScript 变量通常是大写的，在多个单词之间使用下划线`_`连接。

## boolean 强制类型转换

在 JavaScript 中“falsy”的明确列表如下：

- `""` （空字符串）
- `0`, `-0`, `NaN` （非法的`number`）
- `null`, `undefined`
- `false`

任何不在这个“falsy”列表中的值都是“truthy”。这是其中的一些例子：

- `"hello"`
- `42`
- `true`
- `[ ]`, `[ 1, "2", 3 ]` （数组）
- `{ }`, `{ a: 42 }` （对象）
- `function foo() { .. }` （函数）

为了将这许多细节归纳为一个简单的包装，并帮助你在各种情况下判断是否使用`==`或`===`，这是我的简单规则：

- 如果一个比较的两个值之一可能是`true`或`false`值，避免`==`而使用`===`。
- 如果一个比较的两个值之一可能是这些具体的值（`0`，`""`，或`[]` —— 空数组），避免`==`而使用`===`。
- 在 _所有_ 其他情况下，你使用`==`是安全的。它不仅安全，而且在许多情况下它可以简化你的代码并改善可读性。

这些规则归纳出来的东西要求你严谨地考虑你的代码：什么样的值可能通过这个被比较等价性的变量。如果你可以确定这些值，那么`==`就是安全的，使用它！如果你不能确定这些值，就使用`===`。就这么简单。

## JS 的 this 指向

```js
function foo() {
  console.log(this.bar)
}
var bar = 'global'
var obj1 = {
  bar: 'obj1',
  foo: foo
}
var obj2 = {
  bar: 'obj2'
}
// --------

foo() // "global"
obj1.foo() // "obj1"
foo.call(obj2) // "obj2"
new foo() // undefined
```

关于`this`如何被设置有四个规则，它们被展示在这个代码段的最后四行中：

1.  `foo()`最终在非 strict 模式中将`this`设置为全局对象 —— 在 strict 模式中，`this`将会是`undefined`而且你会在访问`bar`属性时得到一个错误 —— 所以`this.bar`的值是`global`。
2.  `obj1.foo()`将`this`设置为对象`obj1`。
3.  `foo.call(obj2)`将`this`设置为对象`obj2`。
4.  `new foo()`将`this`设置为一个新的空对象。

底线：要搞清楚`this`指向什么，你必须检视当前的函数是如何被调用的。它将是我们刚刚看到的四种中的一种，而这将会回答`this`是什么
