# 第一章：什么是作用域？

## 编译器理论

在传统的编译型语言处理中，一块儿源代码，你的程序，在它被执行 _之前_ 通常将会经历三个步骤，大致被称为“编译”：

1.  **分词/词法分析：** 将一连串字符打断成（对于语言来说）有意义的片段，称为 token（记号）。举例来说，考虑这段程序：`var a = 2;`。这段程序很可能会被打断成如下 token：`var`，`a`，`=`，`2`，和 `;`。空格也许会被保留为一个 token，这要看它是否是有意义的。
    **注意：** 分词和词法分析之间的区别是微妙和学术上的，其中心在于这些 token 是否以 _无状态_ 或 _有状态_ 的方式被识别。简而言之，如果分词器去调用有状态的解析规则来弄清`a`是否应当被考虑为一个不同的 token，还是只是其他 token 的一部分，那么这就是 **词法分析**。

2.  **解析：** 将一个 token 的流（数组）转换为一个嵌套元素的树，它综合地表示了程序的语法结构。这棵树称为“抽象语法树”（AST —— <b>A</b>bstract <b>S</b>yntax <b>T</b>ree）。
    `var a = 2;` 的树也许开始于称为 `VariableDeclaration`（变量声明）顶层节点，带有一个称为 `Identifier`（标识符）的子节点（它的值为 `a`），和另一个称为 `AssignmentExpression`（赋值表达式）的子节点，而这个子节点本身带有一个称为 `NumericLiteral`（数字字面量）的子节点（它的值为`2`）。

3.  **代码生成：** 这个处理将抽象语法树转换为可执行的代码。这一部分将根据语言，它的目标平台等因素有很大的不同。
    所以，与其深陷细节，我们不如笼统地说，有一种方法将我们上面描述的 `var a = 2;` 的抽象语法树转换为机器指令，来实际上 _创建_ 一个称为 `a` 的变量（包括分配内存等等），然后在 `a` 中存入一个值。
    **注意：** 引擎如何管理系统资源的细节远比我们要挖掘的东西深刻，所以我们将理所当然地认为引擎有能力按其需要创建和存储变量。

和大多数其他语言的编译器一样，JavaScript 引擎要比这区区三步复杂太多了。例如，在解析和代码生成的处理中，一定会存在优化执行效率的步骤，包括压缩冗余元素，等等。

## LHS & RHS

| 查询方式 | 定义                                         | 详情                                               | 概念上理解 |
| -------- | -------------------------------------------- | -------------------------------------------------- | ---------- |
| LHS      | 变量出现在赋值操作的**左**手边时会进行该查询 | LHS 查询是试着找到变量容器本身，以便它可以**赋值** | 赋值的目标 |
| RHS      | 变量出现在赋值操作的**右**手边时会进行该查询 | 难以察觉，因为它简单地**查询某个变量**的值         | 赋值的源   |

从这种意义上说，RHS 的含义实质上不是 真正的 “一个赋值的右手边”，更准确地说，它只是意味着“不是左手边”。
“RHS”意味着“取得他/她的源（值）”，暗示着 RHS 的意思是“去取……的值”

**注意：** LHS 和 RHS 意味着“赋值的左/右手边”未必像字面上那样意味着“ = 赋值操作符的左/右边”。赋值有几种其他的发生形式，所以最好在概念上将它考虑为：“赋值的目标（LHS）”和“赋值的源（RHS）”